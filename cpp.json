{
	// Place your snippets for cpp here. 
	//Each snippet is defined under a snippet name and has a prefix, body and 
	// description. 
	//The prefix is what is used to trigger the snippet
	// the body will be expanded and inserted. 
	//Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
		

	"Default cpp formate": {
		"prefix": [
			"include"
		],
			"body": [
			"// #pragma GCC optimize(\"Ofast,unroll-loops\")",
			"// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,mmx,avx,avx2\")",
			"#include <bits/stdc++.h>",
			"using namespace std;\n",
            		"#define ll long long",
            		"#define ull unsigned long long",
            		"#define lld long double",
			"#define w(x) ll x;cin>>x;while(x--)",
			"#define all(x) x.begin(), x.end()",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define gcd(a,b)	__gcd(a,b)",
			"#define lcm(a,b)	__detail::__lcm(a,b)",
			"#define iceil(n, x) (((n) + (x) - 1) / (x))",
			"#define goog(tno) cout << \"Case #\" << tno <<\": \"",
			"#define PRESS_F_TO_PAY_RESPECT ios_base::sync_with_stdio(false), cin.tie(nullptr)\n",
			"void __print(int x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}"
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");} ",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
			"#ifndef ONLINE_JUDGE",
			"#define bug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"#else",
			"#define bug(x...)",
			"#endif\n",				
			"ll dx[]= {-1,-1,-1,0,0,1,1,1};",
			"ll dy[]= {-1,0,1,-1,1,-1,0,1};",
			"const lld pi=3.1415926535897932384626433832795;",
			"const ll INF=1e18;",
			"const ll mod=1000000007;",
			"const ll maxn=1e5+5;",
			"\n",
			"template<typename T>",
			"void printv(const vector<T>& v) { for(auto i:v) cout<<i<<' '; cout<<'\\n'; }",
			"template<typename T>",
			"void printv(const vector<pair<T, T>>& v) { for(auto p:v) cout<<\"(\"<<p.first<<\",\"<<p.second<<\"),\"; cout<<'\\n'; }",
			"\n",
			"int main(){",
			"	PRESS_F_TO_PAY_RESPECT;",
			"	//freopen(\"input.txt\",\"r\",stdin);",
			"	//freopen(\"output.txt\",\"w\",stdout);",
			"	$0",
			"    return 0;",
			"}",
		],
		"description": "This is a C++ snippet",
	},
	"My Custom hash":{
		"prefix": "custom_hash",
		"body": [
			"struct custom_hash {",
			"	static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			
			"	size_t operator()(uint64_t x) const {",
			" 	   static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"		return splitmix64(x + FIXED_RANDOM);",
			"	}",
			"};",
		],
		"description": "Avoid collisions in Hash map",
	},
	"Check Prime or Not":{
		"prefix": "ckprime",
		"body": [
			"bool is_prime(ll n){",
			"	if(n<=1) return false;",
			"	for(ll i=2;i*i<=n;i++){",
			"		if(n%i==0)  return false;",
			"	}",
			"	return true;",
			"}",
		],
		"description": "Check Prime or not",
	},
	"Fast Power":{
		"prefix": "fpm",
		"body": [
			"ll fpm(ll x,ll y,ll mod){",
			"	ll res=1;",
			"	while(y>0){",
			"		if(y&1LL){",
			"			res=(res*x)%mod;",
			"		}",
			"		y=y>>1LL;",
			"		x=(x*x)%mod;",
			"	}",
			"	return (res%mod);",
			"}",
		],
		"description": "Fast Exponentiation",
	},
	"Combinatorics1":{
		"prefix": "ncr",
		"body": [
			"ull ncr(ull n,ull r){",
			"	ll p=1,k=1;",
			"	if(n-r<r)",
			"		r=n-r;",
			"	if(r!=0){",
			"		while(r){",
			"			p*=n;",
			"			k*=r;",
			"			ll m=__gcd(p,k);",
			"			p/=m;",
			"			k/=m;",
			"			n--;",
			"			r--;",
			"		}",
			"	}",
			"	else	p = 1;",
			"	return p;",
			"}",
		],
		"description": "ncr",
	},
	"Combinatorics2":{
		"prefix":"fact",
		"body": [
			"ull fact(ull n){",
			"	ull res=1;",
			"	for(auto i=2;i<=n;i++){",
			"		res=res*i;",
			"	}",
			"	return res;",
			"}",
		],
		"description": "Factorial",
	},
	"Modulo Helper":{
		"prefix": "minto",
		"body": [
			"template< ll mod >",
			"struct ModInt {",
			"  ll x;",
			 
			"  ModInt() : x(0) {}",
			 
			"  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
			  
			"  ModInt &operator+=(const ModInt &p) {",
			"	if((x += p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator-=(const ModInt &p) {",
			"	if((x += mod - p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator*=(const ModInt &p) {",
			"	x = (int) (1LL * x * p.x % mod);",
			"	return *this;",
			"  }",
			"  ModInt &operator/=(const ModInt &p) {",
			"	*this *= p.inverse();",
			"	return *this;",
			"  }",
			"  ModInt operator-() const { return ModInt(-x); }",
			"  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
			"  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
			"  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
			"  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
			"  bool operator==(const ModInt &p) const { return x == p.x; }",
			"  bool operator!=(const ModInt &p) const { return x != p.x; }",
			 
			"  ModInt inverse() const {",
			"	ll a = x, b = mod, u = 1, v = 0, t;",
			"	while(b > 0) {",
			"	  t = a / b;",
			"	  swap(a -= t * b, b);",
			"	  swap(u -= t * v, v);",
			"	}",
			"	return ModInt(u);",
			"  }",
			"  ModInt pow(int64_t n) const {",
			"	ModInt ret(1), mul(x);",
			"	while(n > 0) {",
			"	  if(n & 1LL) ret *= mul;",
			"	  mul *= mul;",
			"	  n >>= 1LL;",
			"	}",
			"	return ret;",
			"  }",
			"  friend ostream &operator<<(ostream &os, const ModInt &p) {",
			"	return os << p.x;",
			"  }",
			"  friend istream &operator>>(istream &is, ModInt &a) {",
			"	int64_t t;",
			"	is >> t;",
			"	a = ModInt< mod >(t);",
			"	return (is);",
			"  }",
			"  static ll get_mod() { return mod; }",
			"};",
			"using mint = ModInt< mod >;",
		],
		"description": "Mint Operation",
	},
	"Miller Rabin":{
		"prefix": "miller",
		"body": [
			"using u64 = uint64_t;",
			"using u128 = __uint128_t;",
			
			"u64 binpower(u64 base, u64 e, u64 mod) {",
			"	u64 result = 1;",
			"	base %= mod;",
			"	while (e) {",
			"		if (e & 1)",
			"			result = (u128)result * base % mod;",
			"		base = (u128)base * base % mod;",	
			"		e >>= 1;",
			"	}",
			"	return result;",
			"}",
			
			"bool check_composite(u64 n, u64 a, u64 d, int s) {",
			"	u64 x = binpower(a, d, n);",
			"	if (x == 1 || x == n - 1)",
			"		return false;",
			"	for (int r = 1; r < s; r++) {",
			"		x = (u128)x * x % n;",
			"		if (x == n - 1)",
			"			return false;",
			"	}",
			"	return true;",
			"};",
			
			"bool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.",
			"	if (n < 4)",
			"		return n == 2 || n == 3;",
			
			"	int s = 0;",
			"	u64 d = n - 1;",
			"	while ((d & 1) == 0) {",
			"		d >>= 1;",
			"		s++;",
			"	}",
			
			"	for (int i = 0; i < iter; i++) {",
			"		int a = 2 + rand() % (n - 3);",
			"		if (check_composite(n, a, d, s))",
			"			return false;"
			"	}",
			"	return true;",
			"}",
		],
		"description": "prime number test",
	},
	"Seive Of Eratosthenes":{
		"prefix": "seive",
		"body":[
			"bool prime[(ll)maxn];",
			"vector<ll> primes;",
			
			"void seive(){",
			"	memset(prime, true, sizeof(prime));",
			"	for (ll p = 2; p * p <= maxn; p++){",
			"		if (prime[p] == true) {",
			"			for (ll i = p * p; i <= maxn; i += p)",
			"				prime[i] = false;",
			"		}",
			"	}",
			"	for (ll p = 2; p <= maxn; p++) if (prime[p])   primes.push_back(p);",
			"}",
		],
		"description": "primes number till n",
	},
	"Smallest Prime Factor in O(logn)":{
		"prefix": "spf",
		"body": [
			"ll spf[maxn];",
			"void SPF() {", 
			"	spf[1] = 1;", 
			"	for (ll i = 2; i < maxn; i++) spf[i] = i;", 
			"	for (ll i=4; i<maxn; i+=2) spf[i] = 2;",
			  
			"	for (ll i=3; i*i<maxn; i++) {", 
			"		if (spf[i] == i) {", 
			"			for (ll j=i*i; j<maxn; j+=i)", 
			"				if (spf[j]==j) spf[j] = i;", 
			"		}", 
			"	}", 
			"}",
			
			"ll check[maxn];",
			"void getFactorization(ll x) {", 
			"	while (x != 1) {",
			"		check[spf[x]] = 1;",
			"		x = x / spf[x];", 
			"	}",
			"}",
		],
		"description": "smallest prime factor in logn",
	},
	"Subtract 1 from string":{
		"prefix": "subone",
		"body": [
			"string subone(string& num){",
			"	string res = \"\";",
			"	bool done = 0;",
			"	for(int i = num.length() - 1; i >=0; i--){",
			"	   if(num[i] != '0')",
			"			{num[i] = char(num[i] - 1);break;}",
			"		else num[i] = '9';",
			"	}",
			"	for(int i = 0; i < num.length(); i++){",
			"			res.push_back(num[i]);",
			"	}",
			"	//if(res == \"\")res =\"0\";",
			"	return res;",
			"}",
		],
		"description": "Use in digit dp",
	},
	"Convex Hull":{
		"prefix": "convex",
		"body": [
			"struct pt {",
			"	double x, y;",
			"};",
			
			"bool cmp(pt a, pt b) {",
			"	return a.x < b.x || (a.x == b.x && a.y < b.y);",
			"}",
			
			"bool cw(pt a, pt b, pt c) {",
			"	return a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) < 0;",
			"}",
			
			"bool ccw(pt a, pt b, pt c) {",
			"	return a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) > 0;",
			"}",
			
			"void convex_hull(vector<pt>& a) {",
			"	if (a.size() == 1)",
			"		return;",
			
			"	sort(a.begin(), a.end(), &cmp);",
			"	pt p1 = a[0], p2 = a.back();",
			"	vector<pt> up, down;",
			"	up.push_back(p1);",
			"	down.push_back(p1);",
			"	for (int i = 1; i < (int)a.size(); i++) {",
			"		if (i == a.size() - 1 || cw(p1, a[i], p2)) {",
			"			while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i]))",
			"				up.pop_back();",
			"			up.push_back(a[i]);",
			"		}",
			"		if (i == a.size() - 1 || ccw(p1, a[i], p2)) {",
			"			while(down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i]))",
			"				down.pop_back();",
			"			down.push_back(a[i]);",
			"		}",
			"	}",
			
			"	a.clear();",
			"	for (int i = 0; i < (int)up.size(); i++)",
			"		a.push_back(up[i]);",
			"	for (int i = down.size() - 2; i > 0; i--)",
			"		a.push_back(down[i]);",
			"}",
		],
		"description": "Find Convex hull points",
	}
}
