{
	// Place your snippets for cpp here. 
	//Each snippet is defined under a snippet name and has a prefix, body and 
	// description. 
	//The prefix is what is used to trigger the snippet
	// the body will be expanded and inserted. 
	//Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
		

	"Default cpp formate": {
		"prefix": [
			"include"
		],
			"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;\n",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template<class key, class cmp = std::less<key>>",
			"using oset = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
			"template<class key, class value, class cmp = std::less<key>>",
			"using omap = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n",

		    	"#define ll long long",
		    	"#define lld long double",
			"#define w(x) ll x;cin>>x;while(x--)",
			"#define all(x) x.begin(), x.end()",
			"#define iceil(n, x) (((n) + (x) - 1) / (x))",
			"#define gcd(a,b)	__gcd(a,b)",
			"#define lcm(a,b)	__detail::__lcm(a,b)",
			"#define goog(tno) cout << \"Case #\" << tno <<\": \"\n",
			"void __print(int x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
			"void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");} ",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
			"#ifndef ONLINE_JUDGE",
			"#define bug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"#else",
			"#define bug(x...)",
			"#endif\n",				
			"ll dx[]= {-1,-1,-1,0,0,1,1,1};",
			"ll dy[]= {-1,0,1,-1,1,-1,0,1};",
			"const ll INF=2e18;",
			"const ll mod=1000000007;",
			"const ll maxn=1e5+5;\n",
			"int main(){",
			"	ios_base::sync_with_stdio(false), cin.tie(nullptr);",
			"	//freopen(\"input.txt\",\"r\",stdin);",
			"	//freopen(\"output.txt\",\"w\",stdout);",
			"	$0",
			"    return 0;",
			"}",
		],
		"description": "This is a C++ snippet",
	},
	"My Custom hash":{
		"prefix": "custom_hash",
		"body": [
			"struct custom_hash {",
			"	static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			
			"	size_t operator()(uint64_t x) const {",
			" 	   static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"		return splitmix64(x + FIXED_RANDOM);",
			"	}",
			"};",
		],
		"description": "Avoid collisions in Hash map",
	},
	"Check Prime or Not":{
		"prefix": "ckprime",
		"body": [
			"bool is_prime(ll n){",
			"	if(n<=1) return false;",
			"	for(ll i=2;i*i<=n;i++){",
			"		if(n%i==0)  return false;",
			"	}",
			"	return true;",
			"}",
		],
		"description": "Check Prime or not",
	},
	"Fast Power":{
		"prefix": "fpm",
		"body": [
			"ll fpm(ll x,ll y,ll mod){",
			"	ll res=1;",
			"	while(y>0){",
			"		if(y&1LL){",
			"			res=(res*x)%mod;",
			"		}",
			"		y=y>>1LL;",
			"		x=(x*x)%mod;",
			"	}",
			"	return (res%mod);",
			"}",
		],
		"description": "Fast Exponentiation",
	},
	"Combinatorics1":{
		"prefix": "ncr",
		"body": [
			"ull ncr(ull n,ull r){",
			"	ll p=1,k=1;",
			"	if(n-r<r)",
			"		r=n-r;",
			"	if(r!=0){",
			"		while(r){",
			"			p*=n;",
			"			k*=r;",
			"			ll m=__gcd(p,k);",
			"			p/=m;",
			"			k/=m;",
			"			n--;",
			"			r--;",
			"		}",
			"	}",
			"	else	p = 1;",
			"	return p;",
			"}",
		],
		"description": "ncr",
	},
	"Combinatorics2":{
		"prefix":"fact",
		"body": [
			"vector<ll> fact(1000005);",
			"void factorial(){",
			"	fact[0]=fact[1]=1;",
			"	for(ll i=2;i<fact.size();i++){",
			"		fact[i]=fact[i-1]*i;",
			"	}",
			"}",
		],
		"description": "Factorial",
	},
	"Modulo Helper":{
		"prefix": "minto",
		"body": [
			"template< ll mod >",
			"struct ModInt {",
			"  ll x;",
			 
			"  ModInt() : x(0) {}",
			 
			"  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
			  
			"  ModInt &operator+=(const ModInt &p) {",
			"	if((x += p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator-=(const ModInt &p) {",
			"	if((x += mod - p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator*=(const ModInt &p) {",
			"	x = (int) (1LL * x * p.x % mod);",
			"	return *this;",
			"  }",
			"  ModInt &operator/=(const ModInt &p) {",
			"	*this *= p.inverse();",
			"	return *this;",
			"  }",
			"  ModInt operator-() const { return ModInt(-x); }",
			"  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
			"  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
			"  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
			"  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
			"  bool operator<(const ModInt &p) const { return x < p.x; }",
			"  bool operator>(const ModInt &p) const { return x > p.x; }",
			"  bool operator==(const ModInt &p) const { return x == p.x; }",
			"  bool operator!=(const ModInt &p) const { return x != p.x; }",
			"  string to_str() { return to_string(x); }",
			"  ModInt inverse() const {",
			"	ll a = x, b = mod, u = 1, v = 0, t;",
			"	while(b > 0) {",
			"	  t = a / b;",
			"	  swap(a -= t * b, b);",
			"	  swap(u -= t * v, v);",
			"	}",
			"	return ModInt(u);",
			"  }",
			"  ModInt pow(int64_t n) const {",
			"	ModInt ret(1), mul(x);",
			"	while(n > 0) {",
			"	  if(n & 1LL) ret *= mul;",
			"	  mul *= mul;",
			"	  n >>= 1LL;",
			"	}",
			"	return ret;",
			"  }",
			"  friend ostream &operator<<(ostream &os, const ModInt &p) {",
			"	return os << p.x;",
			"  }",
			"  friend istream &operator>>(istream &is, ModInt &a) {",
			"	int64_t t;",
			"	is >> t;",
			"	a = ModInt< mod >(t);",
			"	return (is);",
			"  }",
			"  static ll get_mod() { return mod; }",
			"};",
			"using mint = ModInt< mod >;",
		],
		"description": "Mint Operation",
	},
	"Miller Rabin":{
		"prefix": "miller",
		"body": [
			"using u64 = uint64_t;",
			"using u128 = __uint128_t;",
			
			"u64 binpower(u64 base, u64 e, u64 mod) {",
			"	u64 result = 1;",
			"	base %= mod;",
			"	while (e) {",
			"		if (e & 1)",
			"			result = (u128)result * base % mod;",
			"		base = (u128)base * base % mod;",	
			"		e >>= 1;",
			"	}",
			"	return result;",
			"}",
			
			"bool check_composite(u64 n, u64 a, u64 d, int s) {",
			"	u64 x = binpower(a, d, n);",
			"	if (x == 1 || x == n - 1)",
			"		return false;",
			"	for (int r = 1; r < s; r++) {",
			"		x = (u128)x * x % n;",
			"		if (x == n - 1)",
			"			return false;",
			"	}",
			"	return true;",
			"};",
			
			"bool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.",
			"	if (n < 4)",
			"		return n == 2 || n == 3;",
			
			"	int s = 0;",
			"	u64 d = n - 1;",
			"	while ((d & 1) == 0) {",
			"		d >>= 1;",
			"		s++;",
			"	}",
			
			"	for (int i = 0; i < iter; i++) {",
			"		int a = 2 + rand() % (n - 3);",
			"		if (check_composite(n, a, d, s))",
			"			return false;"
			"	}",
			"	return true;",
			"}",
		],
		"description": "prime number test",
	},
	"Seive Of Eratosthenes":{
		"prefix": "seive",
		"body":[
			"bool prime[(ll)maxn];",
			"vector<ll> primes;",
			
			"void seive(){",
			"	memset(prime, true, sizeof(prime));",
			"	for (ll p = 2; p * p <= maxn; p++){",
			"		if (prime[p] == true) {",
			"			for (ll i = p * p; i <= maxn; i += p)",
			"				prime[i] = false;",
			"		}",
			"	}",
			"	for (ll p = 2; p <= maxn; p++) if (prime[p])   primes.push_back(p);",
			"}",
		],
		"description": "primes number till n",
	},
	"Smallest Prime Factor in O(logn)":{
		"prefix": "spf",
		"body": [
			"ll spf[maxn];",
			"void SPF() {", 
			"	spf[1] = 1;", 
			"	for (ll i = 2; i < maxn; i++) spf[i] = i;", 
			"	for (ll i=4; i<maxn; i+=2) spf[i] = 2;",
			  
			"	for (ll i=3; i*i<maxn; i++) {", 
			"		if (spf[i] == i) {", 
			"			for (ll j=i*i; j<maxn; j+=i)", 
			"				if (spf[j]==j) spf[j] = i;", 
			"		}", 
			"	}", 
			"}",
			
			"ll check[maxn];",
			"void getFactorization(ll x) {", 
			"	while (x != 1) {",
			"		check[spf[x]] = 1;",
			"		x = x / spf[x];", 
			"	}",
			"}",
		],
		"description": "smallest prime factor in logn",
	},
	"Subtract 1 from string":{
		"prefix": "subone",
		"body": [
			"string subone(string& num){",
			"	string res = \"\";",
			"	bool done = 0;",
			"	for(int i = num.length() - 1; i >=0; i--){",
			"	   if(num[i] != '0')",
			"			{num[i] = char(num[i] - 1);break;}",
			"		else num[i] = '9';",
			"	}",
			"	for(int i = 0; i < num.length(); i++){",
			"			res.push_back(num[i]);",
			"	}",
			"	//if(res == \"\")res =\"0\";",
			"	return res;",
			"}",
		],
		"description": "Use in digit dp",
	},
	"Disjoint Set Union":{
		"prefix": "disjoint",
		"body": [
			"struct dsu{",
			"	ll connected_comp;",
			"	vector<ll> par,sz;",
			"	dsu(ll n){",
			"		par=sz=vector<ll> (n+1,0);",
			"		for(ll i=1;i<=n;i++){",
			"			par[i]=i;",
			"			sz[i]=1;",
			"		}",
			"		connected_comp=n;",
			"	}",
			
			"	ll find_par(ll u){",             
			"		while(u!=par[u]){",
			"			par[u]=par[par[u]];",
			"			u=par[u];",
			"		}",
			"		return u;",
			"	}",
			
			"	void unite(ll u,ll v){",
			"		ll par1=find_par(u);",
			"		ll par2=find_par(v);",
			"		if(par1==par2)  return;",
			"		connected_comp--;",
			"		if(sz[par1]>sz[par2])   swap(par1,par2);",
			"		sz[par2]+=sz[par1];",
			"		sz[par1]=0;",
			"		par[par1]=par[par2];",
			"	}",
			
			"	ll get_size(ll u){",
			"		return sz[find_par(u)];",
			"	}",
			
			"};",
		],
		"description": "Disjoint Set Union",
	},
	"Krukal MST":{
		"prefix": "kruskal",
		"body": [
			"ll n,m;",
			"struct edge",
			"{",
			"   ll x,y,wt;",
			" 	bool operator<(edge const& other){",
			"		return (wt<other.wt);",
			"	}",
			"};",
			"vector<edge> edges;",
			
			"void kruskal(){",
			"	cin>>n>>m;",
			"	ll cost=0;",
			"	for(ll i=1;i<=m;i++){",
			"		ll x,y,w;	cin>>x>>y>>w;",
			"		edges.push_back({x,y,w});",
			"		edges.push_back({y,x,w});",
			"	}",
			"	DSU dsu;",
			"	dsu.init(n);",
			"	sort(all(edges));",
			"	for(auto &e:edges){",
			"		if(dsu.find_par(e.x)!=dsu.find_par(e.y)){",
			"			dsu.unite(e.x,e.y);",
			"			cost+=e.wt;",
			"		}",
			"	}"
			"	cout<<cost<<'\\n';",
			"}",
		]
		"description": "Kruskal MST",
	},
	"Prim MST":{
		"prefix": "prim",
		"body": [
			"ll n,m;",
			"vector<vector<ll>> adj;",
			"struct edge{",
			"	ll w=INF, to=-1;",
			"};",
			
			"void prim(){",
			"	cin>>n>>m;",
			"	adj.resize(n,vector<ll>(n,INF));",
			"	for(ll i=0;i<m;i++){",
			"		ll x,y; cin>>x>>y;",
			"		x--;",
			"		y--;",
			"		ll w;   cin>>w;",
			"		adj[x][y]=w;",
			"		adj[y][x]=w;",
			"	}",
			"	ll cost=0;",
			"	vector<bool> selected(n,0);",
			"	vector<edge> min_e(n);",
			"	min_e[0].w=0;",
			"	for(ll i=0;i<n;i++){",
			"		ll v=-1;",
			"		for(ll j=0;j<n;j++){",
			"			if(!selected[j]&&(v==-1||min_e[j].w<min_e[v].w)){",
			"				v=j;",
			"			}",
			"		}",
			"		if(min_e[v].w==INF){",
			"			cout<<\"NO MST\"<<'\\n';",
			"			exit(0);",
			"		}",
			"		selected[v]=1;",
			"		cost+=min_e[v].w;",
			"		if(min_e[v].to!=-1){",
			"			cout<<v<<\" \"<<min_e[v].to<<'\\n';",
			"		}",
			"		for(ll to=0;to<n;to++){",
			"			if(adj[v][to]<min_e[to].w){",
			"				min_e[to]={adj[v][to],v};",
			"			}",
			"		}",
			"	}",
			"	cout<<cost<<'\\n';",
			"}",
		]
		"description": "Prim MST",
	},
	"Z function":{
		"prefix": "z_function",
		"body": [
			"vector<int> z_function(string& s) {",
			"	int n = (int) s.length();",
			"	vector<int> z(n);",
			"	for (int i = 1, l = 0, r = 0; i < n; ++i) {",
			"		if (i <= r)",
			"			z[i] = min (r - i + 1, z[i - l]);",
			"		while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
			"			++z[i];",
			"		if (i + z[i] - 1 > r)",
			"			l = i, r = i + z[i] - 1;",
			"	}",
			"	return z;",
			"}",
		]
		"description": "Z function",
	},
	"KMP":{
		"prefix": "KMP",
		"body": [
			"vector<int> prefix_function(string& s) {",
			"	int n = (int)s.length();",
			"	vector<int> pi(n);",
			"	for (int i = 1; i < n; i++) {",
			"		int j = pi[i-1];",
			"		while (j > 0 && s[i] != s[j])",
			"			j = pi[j-1];",
			"		if (s[i] == s[j])",
			"			j++;",
			"		pi[i] = j;",
			"	}",
			"	return pi;",
			"}",
		]
		"description": "KMP",
	},
	"Segment Tree": {
		"prefix": "segTree",
		"body": [
		  "template <typename node, typename update>",
		  "struct segTree{",
		  "    ll len;",
		  "    vector<node> t;",
		  "    vector<update> u;",
		  "    vector<bool> lazy;",
		  "    vector<ll> tl,tr;",
		  "    node identity_element;",
		  "    update identity_transformation;",
		  "",
		  "    template<typename T>",
		  "    segTree(T &a){",
		  "        len = a.size();",
		  "        t.resize(4 * len);",
		  "        u.resize(4 * len);",
		  "        lazy.resize(4 * len);",
		  "        tl.resize(4 * len);",
		  "        tr.resize(4 * len);",
		  "        identity_element = node();",
		  "        identity_transformation = update();",
		  "        build(a,1,0,len-1);",
		  "    }",
		  "",
		  "    template <typename T>",
		  "    void build(const T &a, const ll &v, const ll &l, const ll &r){",
		  "        tl[v]=l;",
		  "        tr[v]=r;",
		  "        if (l == r){",
		  "            t[v]=a[l];",
		  "            return;",
		  "        }",
		  "        ll tm = (l + r) >> 1;",
		  "        build(a, v << 1, l, tm);",
		  "        build(a, v << 1 | 1, tm + 1, r);",
		  "        t[v].merge(t[v << 1], t[v << 1 | 1]);",
		  "    }",
		  "",
		  "    void apply(const ll &v, update val){",
		  "        if (tl[v] != tr[v]){",
		  "            lazy[v] = 1;",
		  "            u[v].combine(val, tl[v], tr[v]);",
		  "        }",
		  "        val.apply(t[v], tl[v], tr[v]);",
		  "    }",
		  "",
		  "    void pushdown(const ll &v){",
		  "        if(lazy[v]){",
		  "            apply(v << 1, u[v]);",
		  "            apply(v << 1 | 1, u[v]);",
		  "            u[v] = identity_transformation;",
		  "            lazy[v] = 0;",
		  "        }",
		  "    }",
		  " ",
		  "    // rupd = range update",
		  "    void rupd(const ll &v,const ll &l, const ll &r, update val){",
		  "        if (l > tr[v] || r < tl[v])",
		  "            return;",
		  "        if (tl[v] >= l && tr[v] <= r){",
		  "            apply(v,val);",
		  "            return;",
		  "        }",
		  "        pushdown(v);",
		  "        rupd(v << 1, l, r, val);",
		  "        rupd(v << 1 | 1, l, r, val);",
		  "        t[v].merge(t[v << 1], t[v << 1 | 1]);",
		  "    }",
		  "",
		  "    node query(const ll &v,const ll &l, const ll &r){",
		  "        if (l > tr[v] || r < tl[v])",
		  "            return identity_element;",
		  "        if (tl[v] >= l && tr[v] <= r)",
		  "            return t[v];",
		  "        pushdown(v);",
		  "        node a,b,ans;",
		  "        a=query(v*2,l,r);",
		  "        b=query(v*2+1,l,r);",
		  "        ans.merge(a,b);",
		  "        return ans;",
		  "    }",
		  "",
		  "    template<typename T>",
		  "	ll descent_right(ll l, T x, ll v, node &prev) {",
		  "		if (l > tr[v]) // node is completely out of range",
		  "			return len;",
		  "		if(l <= tl[v]){ // node is completely in range",
		  "			node cur;",
		  "			cur.merge(prev,t[v]);",
		  "			if (!cur.check(x)){ // go further right than this node",
		  "				swap(prev,cur); // merging this node's contribution",
		  "				return len;",
		  "			}",
		  "			if (tl[v]==tr[v]) {",
		  "				return tr[v];",
		  "			}",
		  "		}",
		  "		pushdown(v);",
		  "		ll ans=descent_right(l, x, v*2, prev); // trying to find in left child",
		  "		if(ans!=len)return ans; // found in left child",
		  "		return descent_right(l, x, v*2+1, prev); // finding in right child",
		  "	}",
		  "	template<typename T>",
		  "	ll descent_left(ll r, T x, ll v, node &prev) {",
		  "		if (r < tl[v]) // node is completely out of range",
		  "			return -1;",
		  "		if(r >= tr[v]){ // node is completely in range",
		  "			node cur;",
		  "			cur.merge(t[v],prev);",
		  "			if (!cur.check(x)){ // go further left than this node",
		  "				swap(cur,prev); // merging this node's contribution",
		  "				return -1;",
		  "			}",
		  "			if (tl[v]==tr[v]) {",
		  "				return tl[v];",
		  "			}",
		  "		}",
		  "		pushdown(v);",
		  "		ll ans=descent_left(r, x, v*2+1, prev); // trying to find in right child",
		  "		if(ans!=-1)return ans; // found in right child",
		  "		return descent_left(r, x, v*2, prev); // finding in left child",
		  "	}",
		  "",
		  "    template<typename T>",
		  "	ll descent_right(ll l, T x){ // minimum r such that [l...r].check(x) == true, returns segtree.leng if not found",
		  "		node prev=node();",
		  "		return descent_right(l,x,1,prev);",
		  "	}",
		  "	template<typename T>",
		  "	ll descent_left(ll r, T x){ // maximum l such that [l...r].check(x) == true, returns -1 if not found",
		  "		node prev=node();",
		  "		return descent_left(r,x,1,prev);",
		  "	}",
		  "    node query(const ll &l, const ll &r){",
		  "        return query(1, l, r);",
		  "    }",
		  "    void rupd(const ll &l, const ll &r, update upd){",
		  "        rupd(1, l, r, upd);",
		  "    }",
		  "};",
		  "",
		  "struct node1{",
		  "    ll sum=0;",
		  "    // use more variables if you want more information",
		  "    // these default values should be identity_element",
		  "    ",
		  "    node1() {}",
		  "    node1(ll val){",
		  "        sum=val;",
		  "    }",
		  "    void merge(const node1 &l, const node1 &r){",
		  "        sum=l.sum+r.sum;",
		  "    }",
		  "    bool check(ll x){",
		  "		return false;",
		  "	}",
		  "}; ",
		  "struct update1{",
		  "    ll v=0;",
		  "    // use more variables if you want more information",
		  "    // these default values should be identity_transformation",
		  "    ",
		  "    update1() {}",
		  "    update1(int val){",
		  "        v=val;",
		  "    }",
		  "    // combine the current update1 with the other update1",
		  "    void combine(update1 &other, const ll &tl, const ll &tr){",
		  "        // only needed for range updates",
		  "    }",
		  "    // store the correct information in the node1 x",
		  "    void apply(node1 &x, const ll &tl, const ll &tr){",
		  "        x.sum=v;",
		  "    }",
		  "};"
		],
		"description": "Segment Tree"
	  },
	" Sparse Table": {
		"prefix": "sparseTable",
		"body": [
		  "const ll max_logn=18;",
		  "template<typename T>",
		  "struct sparseTable{",
		  "    vector<ll> log;",
		  "    vector<vector<T>> dp;",
		  "    T combine(T a,T b){",
		  "        return gcd(a,b);",
		  "    }",
		  "    sparseTable(vector<T>& a){",
		  "        ll n=a.size();",
		  "        log.resize(n+5);",
		  "        dp.resize(max_logn,vector<ll>(n+5));",
		  "        log[1]=0;",
		  "        for(ll i=2;i<n+5;i++){",
		  "            log[i]=log[i/2]+1;",
		  "        }",
		  "        init(a);",
		  "    }",
		  "    void init(vector<T>& a){",
		  "        ll n=a.size();",
		  "        for(ll i=0;i<n+5;i++){",
		  "            dp[0][i]=a[i];",
		  "        }",
		  "        for(ll j=1;j<max_logn;j++){",
		  "            for(ll i=0;i+(1LL<<j)<n+5;i++){",
		  "                dp[j][i]=combine(dp[j-1][i],dp[j-1][i+(1LL<<(j-1))]);",
		  "            }",
		  "        }",
		  "    }",
		  "    T query(ll l,ll r){",
		  "        ll j=log[r-l+1];",
		  "        return combine(dp[j][l],dp[j][r-(1LL<<j)+1]);",
		  "    }",
		  "};"
		],
		"description": "Sparse Table"
	  },
		"Fenwick Tree": {
		"prefix": "fenwick",
		"body": [
		"struct fenwick{         ",
		"    // bit[i]=summation in range(p[i]...i);",
		"    // p[i] is magic function for performing efficient operation",
		"    // p[i]=i&(i+1) , used for going forward efficietly in BIT array;",
		"    // for going backward in BIT array efficiently , i=(i|(i+1))",
		"",
		"    vector<ll> bit;",
		"    ll n;",
		"    fenwick(ll n){",
		"        this->n=n;",
		"        bit.resize(n,0);",
		"    }",
		"    fenwick(vector<ll>& a):fenwick(a.size()){",
		"        for(ll i=0;i<a.size();i++){",
		"            add(i,a[i]);",
		"        }",
		"    }",
		"    void upd(ll idx,ll val){",
		"        for(;idx<n;idx=(idx|(idx+1))){",
		"            bit[idx]+=val;",
		"        }",
		"    }",
		"    ll query(ll r){",
		"        ll ans=0;",
		"        for(;r>=0;r=(r&(r+1))-1){",
		"            ans+=bit[r];",
		"        }",
		"        return ans;",
		"    }",
		"    ll rquery(ll l,ll r){",
		"        return query(r)-query(l-1);",
		"    }",
		"};"
		],
		"description": "Fenwick Tree"
		}
}
