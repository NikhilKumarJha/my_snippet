{
	// Place your snippets for cpp here. 
	//Each snippet is defined under a snippet name and has a prefix, body and 
	// description. 
	//The prefix is what is used to trigger the snippet
	// the body will be expanded and inserted. 
	//Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
		

	"Default cpp formate": {
		"prefix": [
			"include"
		],
			"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;\n",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"//All indexing is 0-based"
			"template<class key, class cmp = std::less<key>>",
			"using oset = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
			"//methods: find_by_order(k); & order_of_key(k);",
			"//To make it an ordered_multiset, use pairs of (value, time_of_insertion)",
			"//to distinguish values which are similar ",
			"template<class key, class value, class cmp = std::less<key>>",
			"using omap = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n",

		    	"#define ll long long",
		    	"#define lld long double",
			"#define w(x) ll x;cin>>x;while(x--)",
			"#define all(x) x.begin(), x.end()",
			"#define iceil(n, x) (((n) + (x) - 1) / (x))",
			"#define gcd(a,b)	__gcd(a,b)",
			"#define lcm(a,b)	__detail::__lcm(a,b)",
			"#define goog(tno) cout << \"Case #\" << tno <<\": \"\n",
			"void __print(int x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}"
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");} ",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
			"#ifndef ONLINE_JUDGE",
			"#define bug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"#else",
			"#define bug(x...)",
			"#endif\n",				
			"ll dx[]= {-1,-1,-1,0,0,1,1,1};",
			"ll dy[]= {-1,0,1,-1,1,-1,0,1};",
			"const ll INF=2e18;",
			"const ll mod=1000000007;",
			"const ll maxn=1e5+5;\n",
			"int main(){",
			"	ios_base::sync_with_stdio(false), cin.tie(nullptr);",
			"	//freopen(\"input.txt\",\"r\",stdin);",
			"	//freopen(\"output.txt\",\"w\",stdout);",
			"	$0",
			"    return 0;",
			"}",
		],
		"description": "This is a C++ snippet",
	},
	"My Custom hash":{
		"prefix": "custom_hash",
		"body": [
			"struct custom_hash {",
			"	static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			
			"	size_t operator()(uint64_t x) const {",
			" 	   static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"		return splitmix64(x + FIXED_RANDOM);",
			"	}",
			"};",
		],
		"description": "Avoid collisions in Hash map",
	},
	"Check Prime or Not":{
		"prefix": "ckprime",
		"body": [
			"bool is_prime(ll n){",
			"	if(n<=1) return false;",
			"	for(ll i=2;i*i<=n;i++){",
			"		if(n%i==0)  return false;",
			"	}",
			"	return true;",
			"}",
		],
		"description": "Check Prime or not",
	},
	"Fast Power":{
		"prefix": "fpm",
		"body": [
			"ll fpm(ll x,ll y,ll mod){",
			"	ll res=1;",
			"	while(y>0){",
			"		if(y&1LL){",
			"			res=(res*x)%mod;",
			"		}",
			"		y=y>>1LL;",
			"		x=(x*x)%mod;",
			"	}",
			"	return (res%mod);",
			"}",
		],
		"description": "Fast Exponentiation",
	},
	"Combinatorics1":{
		"prefix": "ncr",
		"body": [
			"ull ncr(ull n,ull r){",
			"	ll p=1,k=1;",
			"	if(n-r<r)",
			"		r=n-r;",
			"	if(r!=0){",
			"		while(r){",
			"			p*=n;",
			"			k*=r;",
			"			ll m=__gcd(p,k);",
			"			p/=m;",
			"			k/=m;",
			"			n--;",
			"			r--;",
			"		}",
			"	}",
			"	else	p = 1;",
			"	return p;",
			"}",
		],
		"description": "ncr",
	},
	"Combinatorics2":{
		"prefix":"fact",
		"body": [
			"vector<ll> fact(1000005);",
			"void factorial(){",
			"	fact[0]=fact[1]=1;",
			"	for(ll i=2;i<fact.size();i++){",
			"		fact[i]=fact[i-1]*i;",
			"	}",
			"}",
		],
		"description": "Factorial",
	},
	"Modulo Helper":{
		"prefix": "minto",
		"body": [
			"template< ll mod >",
			"struct ModInt {",
			"  ll x;",
			 
			"  ModInt() : x(0) {}",
			 
			"  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
			  
			"  ModInt &operator+=(const ModInt &p) {",
			"	if((x += p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator-=(const ModInt &p) {",
			"	if((x += mod - p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator*=(const ModInt &p) {",
			"	x = (int) (1LL * x * p.x % mod);",
			"	return *this;",
			"  }",
			"  ModInt &operator/=(const ModInt &p) {",
			"	*this *= p.inverse();",
			"	return *this;",
			"  }",
			"  ModInt operator-() const { return ModInt(-x); }",
			"  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
			"  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
			"  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
			"  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
			"  bool operator<(const ModInt &p) const { return x < p.x; }",
			"  bool operator>(const ModInt &p) const { return x > p.x; }",
			"  bool operator==(const ModInt &p) const { return x == p.x; }",
			"  bool operator!=(const ModInt &p) const { return x != p.x; }",
			"  string to_str() { return to_string(x); }",
			"  ModInt inverse() const {",
			"	ll a = x, b = mod, u = 1, v = 0, t;",
			"	while(b > 0) {",
			"	  t = a / b;",
			"	  swap(a -= t * b, b);",
			"	  swap(u -= t * v, v);",
			"	}",
			"	return ModInt(u);",
			"  }",
			"  ModInt pow(int64_t n) const {",
			"	ModInt ret(1), mul(x);",
			"	while(n > 0) {",
			"	  if(n & 1LL) ret *= mul;",
			"	  mul *= mul;",
			"	  n >>= 1LL;",
			"	}",
			"	return ret;",
			"  }",
			"  friend ostream &operator<<(ostream &os, const ModInt &p) {",
			"	return os << p.x;",
			"  }",
			"  friend istream &operator>>(istream &is, ModInt &a) {",
			"	int64_t t;",
			"	is >> t;",
			"	a = ModInt< mod >(t);",
			"	return (is);",
			"  }",
			"  static ll get_mod() { return mod; }",
			"};",
			"using mint = ModInt< mod >;",
		],
		"description": "Mint Operation",
	},
	"Miller Rabin":{
		"prefix": "miller",
		"body": [
			"using u64 = uint64_t;",
			"using u128 = __uint128_t;",
			
			"u64 binpower(u64 base, u64 e, u64 mod) {",
			"	u64 result = 1;",
			"	base %= mod;",
			"	while (e) {",
			"		if (e & 1)",
			"			result = (u128)result * base % mod;",
			"		base = (u128)base * base % mod;",	
			"		e >>= 1;",
			"	}",
			"	return result;",
			"}",
			
			"bool check_composite(u64 n, u64 a, u64 d, int s) {",
			"	u64 x = binpower(a, d, n);",
			"	if (x == 1 || x == n - 1)",
			"		return false;",
			"	for (int r = 1; r < s; r++) {",
			"		x = (u128)x * x % n;",
			"		if (x == n - 1)",
			"			return false;",
			"	}",
			"	return true;",
			"};",
			
			"bool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.",
			"	if (n < 4)",
			"		return n == 2 || n == 3;",
			
			"	int s = 0;",
			"	u64 d = n - 1;",
			"	while ((d & 1) == 0) {",
			"		d >>= 1;",
			"		s++;",
			"	}",
			
			"	for (int i = 0; i < iter; i++) {",
			"		int a = 2 + rand() % (n - 3);",
			"		if (check_composite(n, a, d, s))",
			"			return false;"
			"	}",
			"	return true;",
			"}",
		],
		"description": "prime number test",
	},
	"Seive Of Eratosthenes":{
		"prefix": "seive",
		"body":[
			"bool prime[(ll)maxn];",
			"vector<ll> primes;",
			
			"void seive(){",
			"	memset(prime, true, sizeof(prime));",
			"	for (ll p = 2; p * p <= maxn; p++){",
			"		if (prime[p] == true) {",
			"			for (ll i = p * p; i <= maxn; i += p)",
			"				prime[i] = false;",
			"		}",
			"	}",
			"	for (ll p = 2; p <= maxn; p++) if (prime[p])   primes.push_back(p);",
			"}",
		],
		"description": "primes number till n",
	},
	"Smallest Prime Factor in O(logn)":{
		"prefix": "spf",
		"body": [
			"ll spf[maxn];",
			"void SPF() {", 
			"	spf[1] = 1;", 
			"	for (ll i = 2; i < maxn; i++) spf[i] = i;", 
			"	for (ll i=4; i<maxn; i+=2) spf[i] = 2;",
			  
			"	for (ll i=3; i*i<maxn; i++) {", 
			"		if (spf[i] == i) {", 
			"			for (ll j=i*i; j<maxn; j+=i)", 
			"				if (spf[j]==j) spf[j] = i;", 
			"		}", 
			"	}", 
			"}",
			
			"ll check[maxn];",
			"void getFactorization(ll x) {", 
			"	while (x != 1) {",
			"		check[spf[x]] = 1;",
			"		x = x / spf[x];", 
			"	}",
			"}",
		],
		"description": "smallest prime factor in logn",
	},
	"Subtract 1 from string":{
		"prefix": "subone",
		"body": [
			"string subone(string& num){",
			"	string res = \"\";",
			"	bool done = 0;",
			"	for(int i = num.length() - 1; i >=0; i--){",
			"	   if(num[i] != '0')",
			"			{num[i] = char(num[i] - 1);break;}",
			"		else num[i] = '9';",
			"	}",
			"	for(int i = 0; i < num.length(); i++){",
			"			res.push_back(num[i]);",
			"	}",
			"	//if(res == \"\")res =\"0\";",
			"	return res;",
			"}",
		],
		"description": "Use in digit dp",
	},
	"Convex Hull":{
		"prefix": "convex",
		"body": [
			"struct pt {",
			"	double x, y;",
			"};",
			
			"bool cmp(pt a, pt b) {",
			"	return a.x < b.x || (a.x == b.x && a.y < b.y);",
			"}",
			
			"bool cw(pt a, pt b, pt c) {",
			"	return a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) < 0;",
			"}",
			
			"bool ccw(pt a, pt b, pt c) {",
			"	return a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y) > 0;",
			"}",
			
			"void convex_hull(vector<pt>& a) {",
			"	if (a.size() == 1)",
			"		return;",
			
			"	sort(a.begin(), a.end(), &cmp);",
			"	pt p1 = a[0], p2 = a.back();",
			"	vector<pt> up, down;",
			"	up.push_back(p1);",
			"	down.push_back(p1);",
			"	for (int i = 1; i < (int)a.size(); i++) {",
			"		if (i == a.size() - 1 || cw(p1, a[i], p2)) {",
			"			while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i]))",
			"				up.pop_back();",
			"			up.push_back(a[i]);",
			"		}",
			"		if (i == a.size() - 1 || ccw(p1, a[i], p2)) {",
			"			while(down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i]))",
			"				down.pop_back();",
			"			down.push_back(a[i]);",
			"		}",
			"	}",
			
			"	a.clear();",
			"	for (int i = 0; i < (int)up.size(); i++)",
			"		a.push_back(up[i]);",
			"	for (int i = down.size() - 2; i > 0; i--)",
			"		a.push_back(down[i]);",
			"}",
		],
		"description": "Find Convex hull points",
	},
	"Disjoint Set Union":{
		"prefix": "disjoint",
		"body": [
			"struct DSU{",
			"	ll connected_comp;",
			"	vector<ll> par,sz;",
			"	void init(ll n){",
			"		par=sz=vector<ll> (n+1,0);",
			"		for(ll i=1;i<=n;i++){",
			"			par[i]=i;",
			"			sz[i]=1;",
			"		}",
			"		connected_comp=n;",
			"	}",
			
			"	ll find_par(ll u){",             
			"		while(u!=par[u]){",
			"			par[u]=par[par[u]];",
			"			u=par[u];",
			"		}",
			"		return u;",
			"	}",
			
			"	void unite(ll u,ll v){",
			"		ll par1=find_par(u);",
			"		ll par2=find_par(v);",
			"		if(par1==par2)  return;",
			"		connected_comp--;",
			"		if(sz[par1]>sz[par2])   swap(par1,par2);",
			"		sz[par2]+=sz[par1];",
			"		sz[par1]=0;",
			"		par[par1]=par[par2];",
			"	}",
			
			"	ll get_size(ll u){",
			"		return sz[find_par(u)];",
			"	}",
			
			"};",
		],
		"description": "Disjoint Set Union",
	},
	"Krukal MST":{
		"prefix": "kruskal",
		"body": [
			"ll n,m;",
			"struct edge",
			"{",
			"   ll x,y,wt;",
			" 	bool operator<(edge const& other){",
			"		return (wt<other.wt);",
			"	}",
			"};",
			"vector<edge> edges;",
			
			"void kruskal(){",
			"	cin>>n>>m;",
			"	ll cost=0;",
			"	for(ll i=1;i<=m;i++){",
			"		ll x,y,w;	cin>>x>>y>>w;",
			"		edges.push_back({x,y,w});",
			"		edges.push_back({y,x,w});",
			"	}",
			"	DSU dsu;",
			"	dsu.init(n);",
			"	sort(all(edges));",
			"	for(auto &e:edges){",
			"		if(dsu.find_par(e.x)!=dsu.find_par(e.y)){",
			"			dsu.unite(e.x,e.y);",
			"			cost+=e.wt;",
			"		}",
			"	}"
			"	cout<<cost<<'\\n';",
			"}",
		]
		"description": "Kruskal MST",
	},
	"Prim MST":{
		"prefix": "prim",
		"body": [
			"ll n,m;",
			"vector<vector<ll>> adj;",
			"struct edge{",
			"	ll w=INF, to=-1;",
			"};",
			
			"void prim(){",
			"	cin>>n>>m;",
			"	adj.resize(n,vector<ll>(n,INF));",
			"	for(ll i=0;i<m;i++){",
			"		ll x,y; cin>>x>>y;",
			"		x--;",
			"		y--;",
			"		ll w;   cin>>w;",
			"		adj[x][y]=w;",
			"		adj[y][x]=w;",
			"	}",
			"	ll cost=0;",
			"	vector<bool> selected(n,0);",
			"	vector<edge> min_e(n);",
			"	min_e[0].w=0;",
			"	for(ll i=0;i<n;i++){",
			"		ll v=-1;",
			"		for(ll j=0;j<n;j++){",
			"			if(!selected[j]&&(v==-1||min_e[j].w<min_e[v].w)){",
			"				v=j;",
			"			}",
			"		}",
			"		if(min_e[v].w==INF){",
			"			cout<<\"NO MST\"<<'\\n';",
			"			exit(0);",
			"		}",
			"		selected[v]=1;",
			"		cost+=min_e[v].w;",
			"		if(min_e[v].to!=-1){",
			"			cout<<v<<\" \"<<min_e[v].to<<'\\n';",
			"		}",
			"		for(ll to=0;to<n;to++){",
			"			if(adj[v][to]<min_e[to].w){",
			"				min_e[to]={adj[v][to],v};",
			"			}",
			"		}",
			"	}",
			"	cout<<cost<<'\\n';",
			"}",
		]
		"description": "Prim MST",
	},
	"Z function":{
		"prefix": "z_function",
		"body": [
			"vector<int> z_function(string& s) {",
			"	int n = (int) s.length();",
			"	vector<int> z(n);",
			"	for (int i = 1, l = 0, r = 0; i < n; ++i) {",
			"		if (i <= r)",
			"			z[i] = min (r - i + 1, z[i - l]);",
			"		while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
			"			++z[i];",
			"		if (i + z[i] - 1 > r)",
			"			l = i, r = i + z[i] - 1;",
			"	}",
			"	return z;",
			"}",
		]
		"description": "Z function",
	},
	"KMP":{
		"prefix": "KMP",
		"body": [
			"vector<int> prefix_function(string& s) {",
			"	int n = (int)s.length();",
			"	vector<int> pi(n);",
			"	for (int i = 1; i < n; i++) {",
			"		int j = pi[i-1];",
			"		while (j > 0 && s[i] != s[j])",
			"			j = pi[j-1];",
			"		if (s[i] == s[j])",
			"			j++;",
			"		pi[i] = j;",
			"	}",
			"	return pi;",
			"}",
		]
		"description": "KMP",
	},
}
