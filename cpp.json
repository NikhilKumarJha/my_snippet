{
	// Place your snippets for cpp here. 
	//Each snippet is defined under a snippet name and has a prefix, body and 
	// description. 
	//The prefix is what is used to trigger the snippet
	// the body will be expanded and inserted. 
	//Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
		

	"Default cpp formate": {
		"prefix": [
			"include"
		],
			"body": [
			"// #pragma GCC optimize(\"Ofast,unroll-loops\")",
			"// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,mmx,avx,avx2\")",
			"#include <bits/stdc++.h>",
            		"#define ll long long",
            		"#define ull unsigned long long",
            		"#define lld long double",
			"#define w(x) ll x;cin>>x;while(x--)",
			"#define all(x) x.begin(), x.end()",
			"#define bug(x) (cerr<<#x<<\":\"<<(x)<<'\\n')",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define gcd(a,b)	__gcd(a,b)",
			"#define lcm(a,b)	__detail::__lcm(a,b)",
			"#define goog(tno) cout << \"Case #\" << tno <<\": \"",
			"#define speed ios_base::sync_with_stdio(false), cin.tie(nullptr)",
			"using namespace std;",
			"const lld pi=3.1415926535897932384626433832795;",
			"const ll INF=1e18;",
			"const ll mod=1000000007;",
			"const ll maxn=1e5+5;",
			"ll dx[]= {-1,-1,-1,0,0,1,1,1};",
			"ll dy[]= {-1,0,1,-1,1,-1,0,1};",
			"\n",
			"template<typename T>",
			"void printv(const vector<T>& v) { for(auto i:v) cout<<i<<' '; cout<<'\\n'; }",
			"template<typename T>",
			"void printv(const vector<pair<T, T>>& v) { for(auto p:v) cout<<\"(\"<<p.first<<\",\"<<p.second<<\"),\"; cout<<'\\n'; }",
			"\n",
			"int main(){",
			"    speed;",
			"	//freopen(\"input.txt\",\"r\",stdin);",
			"	//freopen(\"output.txt\",\"w\",stdout);",
			"	$0",
			"    return 0;",
			"}",
		],
		"description": "This is a C++ snippet",
	},
	"My Custom hash":{
		"prefix": "custom_hash",
		"body": [
			"struct custom_hash {",
			"	static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			
			"	size_t operator()(uint64_t x) const {",
			" 	   static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"		return splitmix64(x + FIXED_RANDOM);",
			"	}",
			"};",
		],
		"description": "Avoid collisions in Hash map",
	},
	"Check Prime or Not":{
		"prefix": "ckprime",
		"body": [
			"bool is_prime(ll n){",
			"	for(ll i=2;i*i<=n;i++){",
			"		if(n%i==0)  return false;",
			"	}",
			"	return true;",
			"}",
		],
		"description": "Check Prime or not",
	},
	"Fast Power":{
		"prefix": "fpm",
		"body": [
			"ll fpm(ll x,ll y,ll mod){",
			"	ll res=1;",
			"	while(y>0){",
			"		if(y&1LL){",
			"			res=(res*x)%mod;",
			"		}",
			"		y=y>>1LL;",
			"		x=(x*x)%mod;",
			"	}",
			"	return (res%mod);",
			"}",
		],
		"description": "Fast Exponentiation",
	},
	"Combinatorics1":{
		"prefix": "ncr",
		"body": [
			"ull ncr(ull n,ull r){",
			"	ll p=1,k=1;",
			"	if(n-r<r)",
			"		r=n-r;",
			"	if(r!=0){",
			"		while(r){",
			"			p*=n;",
			"			k*=r;",
			"			ll m=__gcd(p,k);",
			"			p/=m;",
			"			k/=m;",
			"			n--;",
			"			r--;",
			"		}",
			"	}",
			"	else	p = 1;",
			"	return p;",
			"}",
		],
		"description": "ncr",
	},
	"Combinatorics2":{
		"prefix":"fact",
		"body": [
			"ull fact(ull n){",
			"	ull res=1;",
			"	for(auto i=2;i<=n;i++){",
			"		res=res*i;",
			"	}",
			"	return res;",
			"}",
		],
		"description": "Factorial",
	},
	"Modulo Helper":{
		"prefix": "minto",
		"body": [
			"template< ll mod >",
			"struct ModInt {",
			"  ll x;",
			 
			"  ModInt() : x(0) {}",
			 
			"  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
			  
			"  ModInt &operator+=(const ModInt &p) {",
			"	if((x += p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator-=(const ModInt &p) {",
			"	if((x += mod - p.x) >= mod) x -= mod;",
			"	return *this;",
			"  }",
			"  ModInt &operator*=(const ModInt &p) {",
			"	x = (int) (1LL * x * p.x % mod);",
			"	return *this;",
			"  }",
			"  ModInt &operator/=(const ModInt &p) {",
			"	*this *= p.inverse();",
			"	return *this;",
			"  }",
			"  ModInt operator-() const { return ModInt(-x); }",
			"  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
			"  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
			"  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
			"  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
			"  bool operator==(const ModInt &p) const { return x == p.x; }",
			"  bool operator!=(const ModInt &p) const { return x != p.x; }",
			 
			"  ModInt inverse() const {",
			"	ll a = x, b = mod, u = 1, v = 0, t;",
			"	while(b > 0) {",
			"	  t = a / b;",
			"	  swap(a -= t * b, b);",
			"	  swap(u -= t * v, v);",
			"	}",
			"	return ModInt(u);",
			"  }",
			"  ModInt pow(int64_t n) const {",
			"	ModInt ret(1), mul(x);",
			"	while(n > 0) {",
			"	  if(n & 1LL) ret *= mul;",
			"	  mul *= mul;",
			"	  n >>= 1LL;",
			"	}",
			"	return ret;",
			"  }",
			"  friend ostream &operator<<(ostream &os, const ModInt &p) {",
			"	return os << p.x;",
			"  }",
			"  friend istream &operator>>(istream &is, ModInt &a) {",
			"	int64_t t;",
			"	is >> t;",
			"	a = ModInt< mod >(t);",
			"	return (is);",
			"  }",
			"  static ll get_mod() { return mod; }",
			"};",
			"using mint = ModInt< mod >;",
		],
		"description": "Mint Operation",
	},
	"Miller Rabin":{
		"prefix": "miller",
		"body": [
			"using u64 = uint64_t;",
			"using u128 = __uint128_t;",
			
			"u64 binpower(u64 base, u64 e, u64 mod) {",
			"	u64 result = 1;",
			"	base %= mod;",
			"	while (e) {",
			"		if (e & 1)",
			"			result = (u128)result * base % mod;",
			"		base = (u128)base * base % mod;",	
			"		e >>= 1;",
			"	}",
			"	return result;",
			"}",
			
			"bool check_composite(u64 n, u64 a, u64 d, int s) {",
			"	u64 x = binpower(a, d, n);",
			"	if (x == 1 || x == n - 1)",
			"		return false;",
			"	for (int r = 1; r < s; r++) {",
			"		x = (u128)x * x % n;",
			"		if (x == n - 1)",
			"			return false;",
			"	}",
			"	return true;",
			"};",
			
			"bool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.",
			"	if (n < 4)",
			"		return n == 2 || n == 3;",
			
			"	int s = 0;",
			"	u64 d = n - 1;",
			"	while ((d & 1) == 0) {",
			"		d >>= 1;",
			"		s++;",
			"	}",
			
			"	for (int i = 0; i < iter; i++) {",
			"		int a = 2 + rand() % (n - 3);",
			"		if (check_composite(n, a, d, s))",
			"			return false;"
			"	}",
			"	return true;",
			"}",
		],
		"description": "prime number test",
	},
	"Seive Of Eratosthenes":{
		"prefix": "seive",
		"body":[
			"bool prime[(ll)maxn];",
			"vector<ll> primes;",
			
			"void seive(){",
			"	memset(prime, true, sizeof(prime));",
			"	for (ll p = 2; p * p <= maxn; p++){",
			"		if (prime[p] == true) {",
			"			for (ll i = p * p; i <= maxn; i += p)",
			"				prime[i] = false;",
			"		}",
			"	}",
			"	for (ll p = 2; p <= maxn; p++) if (prime[p])   primes.push_back(p);",
			"}",
		],
		"description": "primes number till n",
	},
}
